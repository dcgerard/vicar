% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/caw.R
\name{caw}
\alias{caw}
\title{Iterative procedure for confounder correction with a procedure that
returns lfdrs.}
\usage{
caw(
  Y,
  X,
  k = NULL,
  cov_of_interest = ncol(X),
  limmashrink = TRUE,
  weight_func = ash_wrap,
  weight_args = list(),
  fa_func = pca_naive,
  fa_args = list(),
  scale_var = TRUE,
  include_intercept = TRUE,
  weight_init = c("all_null", "random", "limma"),
  weight_func_input = c("summary2"),
  degrees_freedom = NULL,
  min_scale = 0.8
)
}
\arguments{
\item{Y}{A matrix of numerics. These are the response variables
where each column has its own variance. In a gene expression
study, the rows are the individuals and the columns are the
genes.}

\item{X}{A matrix of numerics. The covariates of interest.}

\item{k}{A non-negative integer.The number of unobserved
confounders. If not specified and the R package sva is
installed, then this function will estimate the number of
hidden confounders using the methods of Buja and Eyuboglu
(1992).}

\item{cov_of_interest}{A vector of positive integers. The column
numbers of the covariates in X whose coefficients you are
interested in. The rest are considered nuisance parameters and
are regressed out by OLS.}

\item{limmashrink}{A logical. Should we apply hierarchical
shrinkage to the variances (\code{TRUE}) or not (\code{FALSE})?
If \code{degrees_freedom = NULL} and \code{limmashrink = TRUE}
and \code{likelihood = "t"}, then we'll also use the limma
returned degrees of freedom.}

\item{weight_func}{The function that returns the weights (or
lfdr's). Many forms of input are allowed. See
\code{weight_func_input} for details.}

\item{weight_args}{Additional arguments to pass to
\code{weight_func}.}

\item{fa_func}{A factor analysis function. The function must have
as inputs a numeric matrix \code{Y} and a rank (numeric scalar)
\code{r}. It must output numeric matrices \code{alpha} and
\code{Z} and a numeric vector \code{sig_diag}. \code{alpha} is
the estimate of the coefficients of the unobserved confounders,
so it must be an \code{r} by \code{ncol(Y)} matrix. \code{Z}
must be an \code{r} by \code{nrow(Y)} matrix. \code{sig_diag}
is the estimate of the column-wise variances so it must be of
length \code{ncol(Y)}. The default is the function
\code{pca_naive} that just uses the first \code{r} singular
vectors as the estimate of \code{alpha}. The estimated
variances are just the column-wise mean square.}

\item{fa_args}{A list. Additional arguments you want to pass to
fa_func.}

\item{scale_var}{A logical. Should we scale the variance
(\code{TRUE}) or not (\code{FALSE})?}

\item{include_intercept}{A logical. If \code{TRUE}, then it will
check \code{X} to see if it has an intercept term. If not, then
it will add an intercept term. If \code{FALSE}, then \code{X}
will be unchanged.}

\item{weight_init}{A character. How should we initialize the
weights? The options are to initialize in the all-null setting
(\code{"all_null"}), draw the weights randomly form iid
uniforms (\code{"random"}), or run an iteration of
\code{weight_func} prior to the first round of estimating the
confounders (\code{"limma"}). This last step uses limma-ebayes.}

\item{weight_func_input}{The form of input for
\code{weight_func}. Right now only \code{"summary2"} is
supported, but I intend to support all of the following in the
future. If \code{weight_func_input = "summary1"} then the
function only takes p-values as input (called
\code{pvalues}). If \code{weight_func_input = "summary2"}, then
the function only takes a vector of effect estimates
\code{betahat}, a vector of standard errors \code{sebetahat},
and a vector of degrees of freedom \code{degrees_freedom}. If
\code{weight = "summary3"}, then the input is a matrix of
effects \code{betamat}, an array of covariances
\code{cov_array} where the each \code{cov_array[,,i]} is the
covariance of the elements of \code{betamat[i, ]}, and a vector
of degrees of freedom \code{dfvec}. If \code{weight_func_input
= "full"}, then the input is just a response matrix \code{Y}
and a covariate matrix \code{X}.}

\item{degrees_freedom}{if \code{likelihood = "t"}, then this is the
user-defined degrees of freedom for that distribution. If
\code{degrees_freedom} is \code{NULL} then the degrees of
freedom will be the sample size minus the number of covariates
minus \code{k}.}

\item{min_scale}{The minimum estimate for the variance inflation term.}
}
\description{
Quoth the Raven "Caw, caw!"
}
\author{
David Gerard
}
